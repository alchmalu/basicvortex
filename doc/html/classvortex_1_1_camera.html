<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>BasicVortex: vortex::Camera Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BasicVortex
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevortex.html">vortex</a></li><li class="navelem"><a class="el" href="classvortex_1_1_camera.html">Camera</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classvortex_1_1_camera-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vortex::Camera Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="camera_8h_source.html">camera.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae57d7a7f5f57082825fa16c88929e746"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Type</b> { <b>PERSPECTIVE</b>, 
<b>ORTHOGRAPHIC</b>
 }</td></tr>
<tr class="separator:ae57d7a7f5f57082825fa16c88929e746"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99fbb647a77c5edc4a82fb63bea0123f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a99fbb647a77c5edc4a82fb63bea0123f">Camera</a> (void)</td></tr>
<tr class="separator:a99fbb647a77c5edc4a82fb63bea0123f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497b0af81a8c1f89221b98ac4d519bf9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a497b0af81a8c1f89221b98ac4d519bf9">~Camera</a> ()</td></tr>
<tr class="separator:a497b0af81a8c1f89221b98ac4d519bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a5ea0594eec1232e893ced6041134"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ab15a5ea0594eec1232e893ced6041134">Camera</a> (const <a class="el" href="classvortex_1_1_camera.html">Camera</a> &amp;camera)</td></tr>
<tr class="separator:ab15a5ea0594eec1232e893ced6041134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efb3ed1304570980e74939e05a3ebc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvortex_1_1_camera.html">Camera</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a8efb3ed1304570980e74939e05a3ebc7">operator=</a> (const <a class="el" href="classvortex_1_1_camera.html">Camera</a> &amp;camera)</td></tr>
<tr class="separator:a8efb3ed1304570980e74939e05a3ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98acd3f6e0efaacc9a4cb805444425fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98acd3f6e0efaacc9a4cb805444425fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a98acd3f6e0efaacc9a4cb805444425fe">setDepthAtClick</a> (const glm::vec3 &amp;point)</td></tr>
<tr class="memdesc:a98acd3f6e0efaacc9a4cb805444425fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hack Mathias poir pointunderpixel. <br/></td></tr>
<tr class="separator:a98acd3f6e0efaacc9a4cb805444425fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ba3710802ff131708bb22b58275da0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00ba3710802ff131708bb22b58275da0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> ()</td></tr>
<tr class="separator:a00ba3710802ff131708bb22b58275da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Position and orientation</div></td></tr>
<tr class="memitem:a1289cba25a5f6fd5357242a108560d59"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position</a> () const </td></tr>
<tr class="separator:a1289cba25a5f6fd5357242a108560d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dd618393c7dee95370d0e2a9fe7f45"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a32dd618393c7dee95370d0e2a9fe7f45">upVector</a> () const </td></tr>
<tr class="separator:a32dd618393c7dee95370d0e2a9fe7f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5614ba5cfab93d723c92ef0d2dcf79e"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aa5614ba5cfab93d723c92ef0d2dcf79e">viewDirection</a> () const </td></tr>
<tr class="separator:aa5614ba5cfab93d723c92ef0d2dcf79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b49368804f6d8d4d4fdda80ff3689e"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#af9b49368804f6d8d4d4fdda80ff3689e">rightVector</a> () const </td></tr>
<tr class="separator:af9b49368804f6d8d4d4fdda80ff3689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5608533b6c2b0398f2f7912075275f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvortex_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation</a> () const </td></tr>
<tr class="separator:a5608533b6c2b0398f2f7912075275f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c74b05c8f17a0f0d4c87607a1acad42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a5c74b05c8f17a0f0d4c87607a1acad42">setFromModelViewMatrix</a> (const GLdouble *const modelViewMatrix)</td></tr>
<tr class="separator:a5c74b05c8f17a0f0d4c87607a1acad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af324934e474347dd28d66fbaee52cd5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#af324934e474347dd28d66fbaee52cd5f">setFromProjectionMatrix</a> (const float matrix[12])</td></tr>
<tr class="separator:af324934e474347dd28d66fbaee52cd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc32a3c7e48488b2e7209788ae787b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#adc32a3c7e48488b2e7209788ae787b31">setPosition</a> (const glm::vec3 &amp;pos)</td></tr>
<tr class="separator:adc32a3c7e48488b2e7209788ae787b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade88484f8c977451ba8d2f94fa90535c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation</a> (const <a class="el" href="classvortex_1_1_quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr class="separator:ade88484f8c977451ba8d2f94fa90535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1ce99ba39088a8851e646cb0164377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aad1ce99ba39088a8851e646cb0164377">setOrientation</a> (float theta, float phi)</td></tr>
<tr class="separator:aad1ce99ba39088a8851e646cb0164377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a89a4bace6a3fc338efdfd7e53ad721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector</a> (const glm::vec3 &amp;up, bool noMove=true)</td></tr>
<tr class="separator:a3a89a4bace6a3fc338efdfd7e53ad721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4034e9e88b920afce953fdbbd7bcb37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a4034e9e88b920afce953fdbbd7bcb37c">setViewDirection</a> (const glm::vec3 &amp;direction)</td></tr>
<tr class="separator:a4034e9e88b920afce953fdbbd7bcb37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Positioning tools</div></td></tr>
<tr class="memitem:a1189fadc88f07e516d8242d60510c24b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt</a> (const glm::vec3 &amp;target)</td></tr>
<tr class="separator:a1189fadc88f07e516d8242d60510c24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f6c5fe059fe18304704f0052822c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene</a> ()</td></tr>
<tr class="separator:a088f6c5fe059fe18304704f0052822c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcae6d3c45c81a0d435c8b88465d685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aedcae6d3c45c81a0d435c8b88465d685">fitSphere</a> (const glm::vec3 &amp;center, float radius)</td></tr>
<tr class="separator:aedcae6d3c45c81a0d435c8b88465d685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcb5a9e244705b8014a4e03fdd7662a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a5bcb5a9e244705b8014a4e03fdd7662a">fitBoundingBox</a> (const glm::vec3 &amp;min, const glm::vec3 &amp;max)</td></tr>
<tr class="separator:a5bcb5a9e244705b8014a4e03fdd7662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0dadf31ec970d1989da7f9b763362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aa3c0dadf31ec970d1989da7f9b763362">centerScene</a> ()</td></tr>
<tr class="separator:aa3c0dadf31ec970d1989da7f9b763362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1e9c1493f1c3aa9d812571a9e5fb44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a6d1e9c1493f1c3aa9d812571a9e5fb44">interpolateToFitScene</a> ()</td></tr>
<tr class="separator:a6d1e9c1493f1c3aa9d812571a9e5fb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffa5e81af077467486eef14dbe8477c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#abffa5e81af077467486eef14dbe8477c">interpolateTo</a> (const <a class="el" href="classvortex_1_1_frame.html">Frame</a> &amp;fr, float duration)</td></tr>
<tr class="separator:abffa5e81af077467486eef14dbe8477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Frustum</div></td></tr>
<tr class="memitem:ab8fc643e877128e12ab607a78d5f9384"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type</a> () const </td></tr>
<tr class="separator:ab8fc643e877128e12ab607a78d5f9384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8522b4c00551b980a4bb7dc1ef0c3049"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView</a> () const </td></tr>
<tr class="separator:a8522b4c00551b980a4bb7dc1ef0c3049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad744b096a4da01d11fdd4f4586468584"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ad744b096a4da01d11fdd4f4586468584">horizontalFieldOfView</a> () const </td></tr>
<tr class="separator:ad744b096a4da01d11fdd4f4586468584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76ad7a8235f8c049747b71062960859"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio</a> () const </td></tr>
<tr class="separator:af76ad7a8235f8c049747b71062960859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc5483c03649230f61281d5ea96534f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a1fc5483c03649230f61281d5ea96534f">screenWidth</a> () const </td></tr>
<tr class="separator:a1fc5483c03649230f61281d5ea96534f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92165f43ad31f84ae0824d6f0453d506"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a92165f43ad31f84ae0824d6f0453d506">screenHeight</a> () const </td></tr>
<tr class="separator:a92165f43ad31f84ae0824d6f0453d506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a63df99f90547331028cf6b39adf9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a84a63df99f90547331028cf6b39adf9e">getViewport</a> (GLint viewport[4]) const </td></tr>
<tr class="separator:a84a63df99f90547331028cf6b39adf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40590987298a6ce5b19f99562fd24f4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aa40590987298a6ce5b19f99562fd24f4">pixelGLRatio</a> (const glm::vec3 &amp;<a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position</a>) const </td></tr>
<tr class="separator:aa40590987298a6ce5b19f99562fd24f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962f47b9c5987a99d9a7078158899d80"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a962f47b9c5987a99d9a7078158899d80">zNearCoefficient</a> () const </td></tr>
<tr class="separator:a962f47b9c5987a99d9a7078158899d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad539f59505f737c8c8eb95812d2e4dfd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient</a> () const </td></tr>
<tr class="separator:ad539f59505f737c8c8eb95812d2e4dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1409913192789a1f121ebd7fbe85f22"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear</a> () const </td></tr>
<tr class="separator:ac1409913192789a1f121ebd7fbe85f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fb99c63836edcf1e09f4b9b4a6ae74"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar</a> () const </td></tr>
<tr class="separator:ad5fb99c63836edcf1e09f4b9b4a6ae74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bad4dd6c537b8bacea6a5123ff40a6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a3bad4dd6c537b8bacea6a5123ff40a6d">getOrthoWidthHeight</a> (GLdouble &amp;halfWidth, GLdouble &amp;halfHeight) const </td></tr>
<tr class="separator:a3bad4dd6c537b8bacea6a5123ff40a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa165409530aaaab749eacb4a9a97bf24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aa165409530aaaab749eacb4a9a97bf24">getFrustumPlanesCoefficients</a> (GLdouble coef[6][4]) const </td></tr>
<tr class="separator:aa165409530aaaab749eacb4a9a97bf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d93047624bfbd509a6f565df19a2559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a6d93047624bfbd509a6f565df19a2559">setType</a> (Type <a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type</a>)</td></tr>
<tr class="separator:a6d93047624bfbd509a6f565df19a2559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671d9d21ecca0cad24f03469dfa84bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a671d9d21ecca0cad24f03469dfa84bfd">setFieldOfView</a> (float fov)</td></tr>
<tr class="separator:a671d9d21ecca0cad24f03469dfa84bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583bb3032b9f1c3c65793428a37bfad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a583bb3032b9f1c3c65793428a37bfad6">setHorizontalFieldOfView</a> (float hfov)</td></tr>
<tr class="separator:a583bb3032b9f1c3c65793428a37bfad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74492f523853959f56f3c6e17a17b198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a74492f523853959f56f3c6e17a17b198">setFOVToFitScene</a> ()</td></tr>
<tr class="separator:a74492f523853959f56f3c6e17a17b198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346e108c921a16343f410bac8caaa5b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a346e108c921a16343f410bac8caaa5b1">setAspectRatio</a> (float aspect)</td></tr>
<tr class="separator:a346e108c921a16343f410bac8caaa5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c128ba1ce34fc4680eb4a0e834f359b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a6c128ba1ce34fc4680eb4a0e834f359b">setScreenWidthAndHeight</a> (int width, int height)</td></tr>
<tr class="separator:a6c128ba1ce34fc4680eb4a0e834f359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700ee39b9e5178eec0c93f2220f44498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a700ee39b9e5178eec0c93f2220f44498">setZNearCoefficient</a> (float coef)</td></tr>
<tr class="separator:a700ee39b9e5178eec0c93f2220f44498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8988255d952260cf43d673bcec3fb976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a8988255d952260cf43d673bcec3fb976">setZClippingCoefficient</a> (float coef)</td></tr>
<tr class="separator:a8988255d952260cf43d673bcec3fb976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scene radius and center</div></td></tr>
<tr class="memitem:ac4c76c53acc0d5004c3f7369ccb9b7b8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius</a> () const </td></tr>
<tr class="separator:ac4c76c53acc0d5004c3f7369ccb9b7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5347a5539dd6025aa90e13bef6c7df"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter</a> () const </td></tr>
<tr class="separator:a5e5347a5539dd6025aa90e13bef6c7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43369b846e40480b2923f7d2e94cc69"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ae43369b846e40480b2923f7d2e94cc69">distanceToSceneCenter</a> () const </td></tr>
<tr class="separator:ae43369b846e40480b2923f7d2e94cc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112797d898fffa9a90db74ff76bb39bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a112797d898fffa9a90db74ff76bb39bd">setSceneRadius</a> (float radius)</td></tr>
<tr class="separator:a112797d898fffa9a90db74ff76bb39bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2814daeacfb2285fdda667fc78d712f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a2814daeacfb2285fdda667fc78d712f3">setSceneCenter</a> (const glm::vec3 &amp;center)</td></tr>
<tr class="separator:a2814daeacfb2285fdda667fc78d712f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f2ed16798ba41e3b05057e87f19d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a149f2ed16798ba41e3b05057e87f19d3">setSceneCenterFromPixel</a> (const glm::ivec2 &amp;pixel)</td></tr>
<tr class="separator:a149f2ed16798ba41e3b05057e87f19d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630674741802fdb3f5c994d458adb67a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a630674741802fdb3f5c994d458adb67a">setSceneBoundingBox</a> (const glm::vec3 &amp;min, const glm::vec3 &amp;max)</td></tr>
<tr class="separator:a630674741802fdb3f5c994d458adb67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Revolve Around Point</div></td></tr>
<tr class="memitem:add8d6aaae2045b8160356abe5815b28b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#add8d6aaae2045b8160356abe5815b28b">setRevolveAroundPoint</a> (const glm::vec3 &amp;rap)</td></tr>
<tr class="separator:add8d6aaae2045b8160356abe5815b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389bca49d39b2aa442de1fdab84c3681"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a389bca49d39b2aa442de1fdab84c3681">setRevolveAroundPointFromPixel</a> (const glm::ivec2 &amp;pixel)</td></tr>
<tr class="separator:a389bca49d39b2aa442de1fdab84c3681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d92abbc9be534611ddb522f2ef2e78a"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a0d92abbc9be534611ddb522f2ef2e78a">revolveAroundPoint</a> () const </td></tr>
<tr class="separator:a0d92abbc9be534611ddb522f2ef2e78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Associated frame</div></td></tr>
<tr class="memitem:a9521d0740c91a6247b81d97ef0f15778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvortex_1_1_manipulated_camera_frame.html">ManipulatedCameraFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame</a> () const </td></tr>
<tr class="separator:a9521d0740c91a6247b81d97ef0f15778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9293c396c9dd80c08382168e94653772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a9293c396c9dd80c08382168e94653772">setFrame</a> (<a class="el" href="classvortex_1_1_manipulated_camera_frame.html">ManipulatedCameraFrame</a> *const mcf)</td></tr>
<tr class="separator:a9293c396c9dd80c08382168e94653772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">OpenGL matrices</div></td></tr>
<tr class="memitem:a39a25f5ca6b165f7d7108fceb1ccded3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a39a25f5ca6b165f7d7108fceb1ccded3">computeProjectionMatrix</a> () const </td></tr>
<tr class="separator:a39a25f5ca6b165f7d7108fceb1ccded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d6cc36b2b1e70e7bda8c5ee53b0689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ab6d6cc36b2b1e70e7bda8c5ee53b0689">computeModelViewMatrix</a> () const </td></tr>
<tr class="separator:ab6d6cc36b2b1e70e7bda8c5ee53b0689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843fdb14b39932565debcd100b455493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a843fdb14b39932565debcd100b455493"></a>
glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><b>getProjectionMatrix</b> () const </td></tr>
<tr class="separator:a843fdb14b39932565debcd100b455493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9596a02bb2390f6a2ad4a992ef327"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ca9596a02bb2390f6a2ad4a992ef327"></a>
glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><b>getModelViewMatrix</b> () const </td></tr>
<tr class="separator:a9ca9596a02bb2390f6a2ad4a992ef327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20782f4cd578a9c11be96dc749f7acb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a20782f4cd578a9c11be96dc749f7acb6">getProjectionMatrix</a> (double m[16]) const </td></tr>
<tr class="separator:a20782f4cd578a9c11be96dc749f7acb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88c4899161c378365658c7c00c6a0f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aa88c4899161c378365658c7c00c6a0f0">getModelViewMatrix</a> (double m[16]) const </td></tr>
<tr class="separator:aa88c4899161c378365658c7c00c6a0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae389d06f9b3302f7869128ab04d51cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ae389d06f9b3302f7869128ab04d51cca">getModelViewProjectionMatrix</a> (double m[16]) const </td></tr>
<tr class="separator:ae389d06f9b3302f7869128ab04d51cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03673f1997617f5e2271046a41c44791"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03673f1997617f5e2271046a41c44791"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getProjectionMatrix</b> (float m[16]) const </td></tr>
<tr class="separator:a03673f1997617f5e2271046a41c44791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f6333f1ce80f7e6053221bb0babe84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f6333f1ce80f7e6053221bb0babe84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getModelViewMatrix</b> (float m[16]) const </td></tr>
<tr class="separator:ac3f6333f1ce80f7e6053221bb0babe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">World to Camera coordinate systems conversions</div></td></tr>
<tr class="memitem:ac5eb114fe3cd674667c421d302e39ec1"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ac5eb114fe3cd674667c421d302e39ec1">cameraCoordinatesOf</a> (const glm::vec3 &amp;src) const </td></tr>
<tr class="separator:ac5eb114fe3cd674667c421d302e39ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246d49e52fc93293493be1b0d397022e"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a246d49e52fc93293493be1b0d397022e">worldCoordinatesOf</a> (const glm::vec3 &amp;src) const </td></tr>
<tr class="separator:a246d49e52fc93293493be1b0d397022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791edf610b4a7b23fd1a4ba0723a98b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a791edf610b4a7b23fd1a4ba0723a98b6">getCameraCoordinatesOf</a> (const float src[3], float res[3]) const </td></tr>
<tr class="separator:a791edf610b4a7b23fd1a4ba0723a98b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4780e163fadaff0dd28f064636cb14f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a4780e163fadaff0dd28f064636cb14f3">getWorldCoordinatesOf</a> (const float src[3], float res[3]) const </td></tr>
<tr class="separator:a4780e163fadaff0dd28f064636cb14f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2D screen to 3D world coordinate systems conversions</div></td></tr>
<tr class="memitem:a9a29d78038e810abb45cd72bd49be543"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a9a29d78038e810abb45cd72bd49be543">projectedCoordinatesOf</a> (const glm::vec3 &amp;src, const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *<a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame</a>=NULL) const </td></tr>
<tr class="separator:a9a29d78038e810abb45cd72bd49be543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a1d1b0f59fa99cd71ad959c97b6fa2"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a24a1d1b0f59fa99cd71ad959c97b6fa2">unprojectedCoordinatesOf</a> (const glm::vec3 &amp;src, const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *<a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame</a>=NULL) const </td></tr>
<tr class="separator:a24a1d1b0f59fa99cd71ad959c97b6fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58364ba6a63f2541158429e2ecb51d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a58364ba6a63f2541158429e2ecb51d78">getProjectedCoordinatesOf</a> (const float src[3], float res[3], const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *<a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame</a>=NULL) const </td></tr>
<tr class="separator:a58364ba6a63f2541158429e2ecb51d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1467bdf7c906991006997afc26290d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a1467bdf7c906991006997afc26290d80">getUnprojectedCoordinatesOf</a> (const float src[3], float res[3], const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *<a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame</a>=NULL) const </td></tr>
<tr class="separator:a1467bdf7c906991006997afc26290d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc35880e65eeca9151bf1336aa49edb"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a9cc35880e65eeca9151bf1336aa49edb">pointUnderPixel</a> (const glm::ivec2 &amp;pixel, bool &amp;found) const </td></tr>
<tr class="separator:a9cc35880e65eeca9151bf1336aa49edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fly speed</div></td></tr>
<tr class="memitem:a3091775d697fb36f12543a5d14934111"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a3091775d697fb36f12543a5d14934111">flySpeed</a> () const </td></tr>
<tr class="separator:a3091775d697fb36f12543a5d14934111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad234b9d36ca2088ddda022c82c1cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aa2ad234b9d36ca2088ddda022c82c1cb">setFlySpeed</a> (float speed)</td></tr>
<tr class="separator:aa2ad234b9d36ca2088ddda022c82c1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stereo parameters</div></td></tr>
<tr class="memitem:a01d952f360a936a9f249fc39f17dd2fd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a01d952f360a936a9f249fc39f17dd2fd">IODistance</a> () const </td></tr>
<tr class="separator:a01d952f360a936a9f249fc39f17dd2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20ad016f143d6f9de36d8669f5c579f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ad20ad016f143d6f9de36d8669f5c579f">physicalDistanceToScreen</a> () const </td></tr>
<tr class="separator:ad20ad016f143d6f9de36d8669f5c579f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6575485cfb4af6e21d1a4e0a1f5a87"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#acf6575485cfb4af6e21d1a4e0a1f5a87">physicalScreenWidth</a> () const </td></tr>
<tr class="separator:acf6575485cfb4af6e21d1a4e0a1f5a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf462757a4fe400139a86da7355dbcd7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#aaf462757a4fe400139a86da7355dbcd7">focusDistance</a> () const </td></tr>
<tr class="separator:aaf462757a4fe400139a86da7355dbcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2326a2a78a93cbad71986b23d29e2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a0a2326a2a78a93cbad71986b23d29e2a">setIODistance</a> (float distance)</td></tr>
<tr class="separator:a0a2326a2a78a93cbad71986b23d29e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12671e9e27ce10f7faea9ff5a2402c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ad12671e9e27ce10f7faea9ff5a2402c5">setPhysicalDistanceToScreen</a> (float distance)</td></tr>
<tr class="separator:ad12671e9e27ce10f7faea9ff5a2402c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2367c19e34ecb2d0647dd36f7bc560a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#ae2367c19e34ecb2d0647dd36f7bc560a">setPhysicalScreenWidth</a> (float width)</td></tr>
<tr class="separator:ae2367c19e34ecb2d0647dd36f7bc560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804e5653fc479d2d952638a3cf8b7c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvortex_1_1_camera.html#a804e5653fc479d2d952638a3cf8b7c12">setFocusDistance</a> (float distance)</td></tr>
<tr class="separator:a804e5653fc479d2d952638a3cf8b7c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Mathias Paulin <a href="#" onclick="location.href='mai'+'lto:'+'Mat'+'hi'+'as.'+'Pa'+'uli'+'n@'+'iri'+'t.'+'fr'; return false;">Mathi<span style="display: none;">.nosp@m.</span>as.P<span style="display: none;">.nosp@m.</span>aulin<span style="display: none;">.nosp@m.</span>@iri<span style="display: none;">.nosp@m.</span>t.fr</a>, David Vanderhaeghe <a href="#" onclick="location.href='mai'+'lto:'+'vdh'+'@i'+'rit'+'.f'+'r'; return false;">vdh@i<span style="display: none;">.nosp@m.</span>rit.<span style="display: none;">.nosp@m.</span>fr</a> Mainly code copied and adapted from QGLViewer Copyright (C) 2002-2008 Gilles Debunne. All rights reserved.</dd></dl>
<p><a class="el" href="classvortex_1_1_camera.html">Camera</a> representation class </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>: manage look at point (for rotate around point) </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a99fbb647a77c5edc4a82fb63bea0123f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vortex::Camera::Camera </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default Constructor : initialize <a class="el" href="classvortex_1_1_camera.html">Camera</a> attributes</p>
<p>Default constructor.</p>
<p><a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> is set to (0,0,0) and <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> is set to 1.0. <a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type()</a> is Camera::PERSPECTIVE, with a <code>M_PI/4</code> <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a>.</p>
<p>See <a class="el" href="classvortex_1_1_camera.html#a01d952f360a936a9f249fc39f17dd2fd">IODistance()</a>, <a class="el" href="classvortex_1_1_camera.html#ad20ad016f143d6f9de36d8669f5c579f">physicalDistanceToScreen()</a>, <a class="el" href="classvortex_1_1_camera.html#acf6575485cfb4af6e21d1a4e0a1f5a87">physicalScreenWidth()</a> and <a class="el" href="classvortex_1_1_camera.html#aaf462757a4fe400139a86da7355dbcd7">focusDistance()</a> documentations for default stereo parameter values. </p>

</div>
</div>
<a class="anchor" id="a497b0af81a8c1f89221b98ac4d519bf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vortex::Camera::~Camera </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual destructor.</p>
<p>The <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a> is deleted, but the different keyFrameInterpolator() are <em>not</em> deleted (in case they are shared). </p>

</div>
</div>
<a class="anchor" id="ab15a5ea0594eec1232e893ced6041134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vortex::Camera::Camera </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_camera.html">Camera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Performs a deep copy using <a class="el" href="classvortex_1_1_camera.html#a8efb3ed1304570980e74939e05a3ebc7">operator=()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af76ad7a8235f8c049747b71062960859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::aspectRatio </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the Camera aspect ratio defined by screenWidth() / screenHeight().
</pre><p>When the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is attached to a QGLViewer, these values and hence the <a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio()</a> are automatically fitted to the viewer's window aspect ratio using <a class="el" href="classvortex_1_1_camera.html#a6c128ba1ce34fc4680eb4a0e834f359b">setScreenWidthAndHeight()</a>. </p>

</div>
</div>
<a class="anchor" id="ac5eb114fe3cd674667c421d302e39ec1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::cameraCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>src</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the Camera frame coordinates of a point \p src defined in world coordinates.
</pre><p><a class="el" href="classvortex_1_1_camera.html#a246d49e52fc93293493be1b0d397022e">worldCoordinatesOf()</a> performs the inverse transformation.</p>
<p>Note that the point coordinates are simply converted in a different coordinate system. They are not projected on screen. Use <a class="el" href="classvortex_1_1_camera.html#a9a29d78038e810abb45cd72bd49be543">projectedCoordinatesOf()</a> for that. </p>

</div>
</div>
<a class="anchor" id="aa3c0dadf31ec970d1989da7f9b763362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::centerScene </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the <a class="el" href="classvortex_1_1_camera.html">Camera</a> so that its <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> is projected on the center of the window. The <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> and <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> are unchanged.</p>
<p>Simply projects the current position on a line passing through <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>. See also <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a>. </p>

</div>
</div>
<a class="anchor" id="ab6d6cc36b2b1e70e7bda8c5ee53b0689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::computeModelViewMatrix </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the modelView matrix associated with the <a class="el" href="classvortex_1_1_camera.html">Camera</a>'s <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> and <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a>.</p>
<p>This matrix converts from the world coordinates system to the <a class="el" href="classvortex_1_1_camera.html">Camera</a> coordinates system, so that coordinates can then be projected on screen using the projection matrix (see <a class="el" href="classvortex_1_1_camera.html#a39a25f5ca6b165f7d7108fceb1ccded3">computeProjectionMatrix()</a>).</p>
<p>Use getModelViewMatrix() to retrieve this matrix.</p>
<dl class="section note"><dt>Note</dt><dd>You must call this method if your <a class="el" href="classvortex_1_1_camera.html">Camera</a> is not associated with a QGLViewer and is used for offscreen computations (using (un)<a class="el" href="classvortex_1_1_camera.html#a9a29d78038e810abb45cd72bd49be543">projectedCoordinatesOf()</a> for instance). loadModelViewMatrix() does it otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a39a25f5ca6b165f7d7108fceb1ccded3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::computeProjectionMatrix </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the projection matrix associated with the <a class="el" href="classvortex_1_1_camera.html">Camera</a>.</p>
<p>If <a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type()</a> is Camera::PERSPECTIVE, defines a <code>GL_PROJECTION</code> matrix similar to what would <code>gluPerspective()</code> do using the <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a>, window <a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio()</a>, <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> parameters.</p>
<p>If <a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type()</a> is Camera::ORTHOGRAPHIC, the projection matrix is as what <code>glOrtho()</code> would do. Frustum's width and height are set using <a class="el" href="classvortex_1_1_camera.html#a3bad4dd6c537b8bacea6a5123ff40a6d">getOrthoWidthHeight()</a>.</p>
<p>Both types use <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> to place clipping planes. These values are determined from <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> and <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> so that they best fit the scene size.</p>
<p>Use getProjectionMatrix() to retrieve this matrix. Overload loadProjectionMatrix() if you want your <a class="el" href="classvortex_1_1_camera.html">Camera</a> to use an exotic projection matrix.</p>
<dl class="section note"><dt>Note</dt><dd>You must call this method if your <a class="el" href="classvortex_1_1_camera.html">Camera</a> is not associated with a QGLViewer and is used for offscreen computations (using (un)<a class="el" href="classvortex_1_1_camera.html#a9a29d78038e810abb45cd72bd49be543">projectedCoordinatesOf()</a> for instance). loadProjectionMatrix() does it otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae43369b846e40480b2923f7d2e94cc69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::distanceToSceneCenter </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance from the <a class="el" href="classvortex_1_1_camera.html">Camera</a> center to <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>, projected along the <a class="el" href="classvortex_1_1_camera.html">Camera</a> Z axis. Used by <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> to optimize the Z range. </p>

</div>
</div>
<a class="anchor" id="a8522b4c00551b980a4bb7dc1ef0c3049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::fieldOfView </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the vertical field of view of the Camera (in radians).
</pre><p>Value is set using <a class="el" href="classvortex_1_1_camera.html#a671d9d21ecca0cad24f03469dfa84bfd">setFieldOfView()</a>. Default value is pi/4 radians. This value is meaningless if the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type()</a> is Camera::ORTHOGRAPHIC.</p>
<p>The field of view corresponds the one used in <code>gluPerspective</code> (see manual). It sets the Y (vertical) aperture of the <a class="el" href="classvortex_1_1_camera.html">Camera</a>. The X (horizontal) angle is inferred from the window aspect ratio (see <a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio()</a> and <a class="el" href="classvortex_1_1_camera.html#ad744b096a4da01d11fdd4f4586468584">horizontalFieldOfView()</a>).</p>
<p>Use <a class="el" href="classvortex_1_1_camera.html#a74492f523853959f56f3c6e17a17b198">setFOVToFitScene()</a> to adapt the <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> to a given scene. </p>

</div>
</div>
<a class="anchor" id="a5bcb5a9e244705b8014a4e03fdd7662a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::fitBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the <a class="el" href="classvortex_1_1_camera.html">Camera</a> so that the (world axis aligned) bounding box (<code>min</code>, <code>max</code>) is entirely visible, using <a class="el" href="classvortex_1_1_camera.html#aedcae6d3c45c81a0d435c8b88465d685">fitSphere()</a>. </p>

</div>
</div>
<a class="anchor" id="aedcae6d3c45c81a0d435c8b88465d685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::fitSphere </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the <a class="el" href="classvortex_1_1_camera.html">Camera</a> so that the sphere defined by (<code>center</code>, <code>radius</code>) is visible and fits the window.</p>
<p>The <a class="el" href="classvortex_1_1_camera.html">Camera</a> is simply translated along its <a class="el" href="classvortex_1_1_camera.html#aa5614ba5cfab93d723c92ef0d2dcf79e">viewDirection()</a> so that the sphere fits the screen. Its <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> and its <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> are unchanged.</p>
<p>You should therefore orientate the <a class="el" href="classvortex_1_1_camera.html">Camera</a> before you call this method. See <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a>, <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a> and <a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector()</a>. </p>

</div>
</div>
<a class="anchor" id="a3091775d697fb36f12543a5d14934111"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::flySpeed </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the fly speed of the Camera.
</pre><p>Simply returns <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a>-&gt;<a class="el" href="classvortex_1_1_camera.html#a3091775d697fb36f12543a5d14934111">flySpeed()</a>. See the <a class="el" href="classvortex_1_1_manipulated_camera_frame.html#ab3b1c6c0661b12f16bd9868dd6879feb">ManipulatedCameraFrame::flySpeed()</a> documentation. This value is only meaningful when the MouseAction bindings is QGLViewer::MOVE_FORWARD or QGLViewer::MOVE_BACKWARD.</p>
<p>Set to 0.5% of the <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> by <a class="el" href="classvortex_1_1_camera.html#a112797d898fffa9a90db74ff76bb39bd">setSceneRadius()</a>. See also <a class="el" href="classvortex_1_1_camera.html#aa2ad234b9d36ca2088ddda022c82c1cb">setFlySpeed()</a>. </p>

</div>
</div>
<a class="anchor" id="aaf462757a4fe400139a86da7355dbcd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::focusDistance </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the focus distance used by stereo display, expressed in OpenGL units.
</pre><p>This is the distance in the virtual world between the <a class="el" href="classvortex_1_1_camera.html">Camera</a> and the plane where the horizontal stereo parallax is null (the stereo left and right images are superimposed).</p>
<p>This distance is the virtual world equivalent of the real-world <a class="el" href="classvortex_1_1_camera.html#ad20ad016f143d6f9de36d8669f5c579f">physicalDistanceToScreen()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This value is modified by QGLViewer::setSceneRadius(), <a class="el" href="classvortex_1_1_camera.html#a112797d898fffa9a90db74ff76bb39bd">setSceneRadius()</a> and <a class="el" href="classvortex_1_1_camera.html#a671d9d21ecca0cad24f03469dfa84bfd">setFieldOfView()</a>. When one of these values is modified, <a class="el" href="classvortex_1_1_camera.html#aaf462757a4fe400139a86da7355dbcd7">focusDistance()</a> is set to <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> / tan(<a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a>/2), which provides good results. </dd></dl>

</div>
</div>
<a class="anchor" id="a9521d0740c91a6247b81d97ef0f15778"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvortex_1_1_manipulated_camera_frame.html">ManipulatedCameraFrame</a>* vortex::Camera::frame </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the ManipulatedCameraFrame attached to the Camera.
</pre><p>This <a class="el" href="classvortex_1_1_manipulated_camera_frame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific mouse bindings...">ManipulatedCameraFrame</a> defines its <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> and <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> and can translate mouse events into <a class="el" href="classvortex_1_1_camera.html">Camera</a> displacement. Set using <a class="el" href="classvortex_1_1_camera.html#a9293c396c9dd80c08382168e94653772">setFrame()</a>. </p>

</div>
</div>
<a class="anchor" id="a791edf610b4a7b23fd1a4ba0723a98b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getCameraCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>res</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classvortex_1_1_camera.html#ac5eb114fe3cd674667c421d302e39ec1">cameraCoordinatesOf()</a>, but with <code>float</code>[3] parameters (<code>src</code> and <code>res</code> may be identical pointers). </p>

</div>
</div>
<a class="anchor" id="aa165409530aaaab749eacb4a9a97bf24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getFrustumPlanesCoefficients </td>
          <td>(</td>
          <td class="paramtype">GLdouble&#160;</td>
          <td class="paramname"><em>coef</em>[6][4])</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the 6 plane equations of the Camera frustum.
</pre><p>The six 4-component vectors of <code>coef</code> respectively correspond to the left, right, near, far, top and bottom <a class="el" href="classvortex_1_1_camera.html">Camera</a> frustum planes. Each vector holds a plane equation of the form: </p>
<div class="fragment"><div class="line">a*x + b*y + c*z + d = 0</div>
</div><!-- fragment --><p> where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are the 4 components of each vector, in that order.</p>
<p>See the <a href="../examples/frustumCulling.html">frustumCulling example</a> for an application.</p>
<p>This format is compatible with the <code>glClipPlane()</code> function. One camera frustum plane can hence be applied in an other viewer to visualize the culling results: </p>
<div class="fragment"><div class="line"><span class="comment">// Retrieve plance equations</span></div>
<div class="line">GLdouble coef[6][4];</div>
<div class="line">mainViewer-&gt;camera()-&gt;getFrustumPlanesCoefficients(coef);</div>
<div class="line"></div>
<div class="line"><span class="comment">// These two additional clipping planes (which must have been enabled)</span></div>
<div class="line"><span class="comment">// will reproduce the mainViewer&#39;s near and far clipping.</span></div>
<div class="line">glClipPlane(GL_CLIP_PLANE0, coef[2]);</div>
<div class="line">glClipPlane(GL_CLIP_PLANE1, coef[3]);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa88c4899161c378365658c7c00c6a0f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getModelViewMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>[16])</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills <code>m</code> with the <a class="el" href="classvortex_1_1_camera.html">Camera</a> modelView matrix values.</p>
<p>First calls <a class="el" href="classvortex_1_1_camera.html#ab6d6cc36b2b1e70e7bda8c5ee53b0689">computeModelViewMatrix()</a> to define the <a class="el" href="classvortex_1_1_camera.html">Camera</a> modelView matrix.</p>
<p>Note that this matrix is usually <em>not</em> the one you would get from a <code>glGetDoublev(GL_MODELVIEW_MATRIX, m)</code>. It actually represents the state of the <code>GL_MODELVIEW</code> after QGLViewer::preDraw(), at the beginning of QGLViewer::draw(). It converts from the world to the <a class="el" href="classvortex_1_1_camera.html">Camera</a> coordinate system. As soon as you modify the <code>GL_MODELVIEW</code> in your QGLViewer::draw() method, the two matrices differ.</p>
<p>The result is an OpenGL 4x4 matrix, which is given in <em>column-major</em> order (see <code>glMultMatrix</code> man page for details).</p>
<p>See also getProjectionMatrix() and <a class="el" href="classvortex_1_1_camera.html#a5c74b05c8f17a0f0d4c87607a1acad42">setFromModelViewMatrix()</a>. </p>

</div>
</div>
<a class="anchor" id="ae389d06f9b3302f7869128ab04d51cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getModelViewProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>[16])</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills <code>m</code> with the product of the ModelView and Projection matrices.</p>
<p>Calls getModelViewMatrix() and getProjectionMatrix() and then fills <code>m</code> with the product of these two matrices. </p>

</div>
</div>
<a class="anchor" id="a3bad4dd6c537b8bacea6a5123ff40a6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getOrthoWidthHeight </td>
          <td>(</td>
          <td class="paramtype">GLdouble &amp;&#160;</td>
          <td class="paramname"><em>halfWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLdouble &amp;&#160;</td>
          <td class="paramname"><em>halfHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <code>halfWidth</code> and <code>halfHeight</code> of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> orthographic frustum.</p>
<p>These values are only valid and used when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is of <a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type()</a> Camera::ORTHOGRAPHIC. They are expressed in OpenGL units and are used by loadProjectionMatrix() to define the projection matrix using: </p>
<div class="fragment"><div class="line">glOrtho( -halfWidth, halfWidth, -halfHeight, halfHeight, <a class="code" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear</a>(), <a class="code" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar</a>() )</div>
</div><!-- fragment --><p>These values are proportional to the <a class="el" href="classvortex_1_1_camera.html">Camera</a> (z projected) distance to the <a class="el" href="classvortex_1_1_camera.html#a0d92abbc9be534611ddb522f2ef2e78a">revolveAroundPoint()</a>. When zooming on the object, the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is translated forward <em>and</em> its frustum is narrowed, making the object appear bigger on screen, as intuitively expected.</p>
<p>Overload this method to change this behavior if desired, as is done in the <a href="../examples/standardCamera.html">standardCamera example</a>. </p>

</div>
</div>
<a class="anchor" id="a58364ba6a63f2541158429e2ecb51d78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getProjectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>res</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classvortex_1_1_camera.html#a9a29d78038e810abb45cd72bd49be543">projectedCoordinatesOf()</a>, but with <code>float</code> parameters (<code>src</code> and <code>res</code> can be identical pointers). </p>

</div>
</div>
<a class="anchor" id="a20782f4cd578a9c11be96dc749f7acb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>[16])</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills <code>m</code> with the <a class="el" href="classvortex_1_1_camera.html">Camera</a> projection matrix values.</p>
<p>Calls <a class="el" href="classvortex_1_1_camera.html#a39a25f5ca6b165f7d7108fceb1ccded3">computeProjectionMatrix()</a> to define the <a class="el" href="classvortex_1_1_camera.html">Camera</a> projection matrix.</p>
<p>This matrix only reflects the <a class="el" href="classvortex_1_1_camera.html">Camera</a>'s internal parameters and it may differ from the <code>GL_PROJECTION</code> matrix retrieved using <code>glGetDoublev(GL_PROJECTION_MATRIX, m)</code>. It actually represents the state of the <code>GL_PROJECTION</code> after QGLViewer::preDraw(), at the beginning of QGLViewer::draw(). If you modified the <code>GL_PROJECTION</code> matrix (for instance using QGLViewer::startScreenCoordinatesSystem()), the two results differ.</p>
<p>The result is an OpenGL 4x4 matrix, which is given in <em>column-major</em> order (see <code>glMultMatrix</code> man page for details).</p>
<p>See also getModelViewMatrix() and <a class="el" href="classvortex_1_1_camera.html#af324934e474347dd28d66fbaee52cd5f">setFromProjectionMatrix()</a>. </p>

</div>
</div>
<a class="anchor" id="a1467bdf7c906991006997afc26290d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getUnprojectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>res</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classvortex_1_1_camera.html#a24a1d1b0f59fa99cd71ad959c97b6fa2">unprojectedCoordinatesOf()</a>, but with <code>float</code> parameters (<code>src</code> and <code>res</code> can be identical pointers). </p>

</div>
</div>
<a class="anchor" id="a84a63df99f90547331028cf6b39adf9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getViewport </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>viewport</em>[4])</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fills \p viewport with the Camera OpenGL viewport.
</pre><p>This method is mainly used in conjunction with <code>gluProject</code>, which requires such a viewport. Returned values are (0, <a class="el" href="classvortex_1_1_camera.html#a92165f43ad31f84ae0824d6f0453d506">screenHeight()</a>, <a class="el" href="classvortex_1_1_camera.html#a1fc5483c03649230f61281d5ea96534f">screenWidth()</a>, - <a class="el" href="classvortex_1_1_camera.html#a92165f43ad31f84ae0824d6f0453d506">screenHeight()</a>), so that the origin is located in the <em>upper</em> left corner of the window (Qt style coordinate system). </p>

</div>
</div>
<a class="anchor" id="a4780e163fadaff0dd28f064636cb14f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::getWorldCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>src</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>res</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classvortex_1_1_camera.html#a246d49e52fc93293493be1b0d397022e">worldCoordinatesOf()</a>, but with <code>float</code>[3] parameters (<code>src</code> and <code>res</code> may be identical pointers). </p>

</div>
</div>
<a class="anchor" id="ad744b096a4da01d11fdd4f4586468584"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::horizontalFieldOfView </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the horizontal field of view of the Camera (in radians).
</pre><p>Value is set using <a class="el" href="classvortex_1_1_camera.html#a583bb3032b9f1c3c65793428a37bfad6">setHorizontalFieldOfView()</a> or <a class="el" href="classvortex_1_1_camera.html#a671d9d21ecca0cad24f03469dfa84bfd">setFieldOfView()</a>. These values are always linked by: </p>
<div class="fragment"><div class="line"><a class="code" href="classvortex_1_1_camera.html#ad744b096a4da01d11fdd4f4586468584">horizontalFieldOfView</a>() = 2.0 * atan ( tan(<a class="code" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView</a>()/2.0) * <a class="code" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio</a>() ).</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abffa5e81af077467486eef14dbe8477c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::interpolateTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smoothly interpolates the <a class="el" href="classvortex_1_1_camera.html">Camera</a> on a KeyFrameInterpolator path so that it goes to <code>fr</code>.</p>
<p><code>fr</code> is expressed in world coordinates. <code>duration</code> tunes the interpolation speed (default is 1 second).</p>
<p>See also <a class="el" href="classvortex_1_1_camera.html#a6d1e9c1493f1c3aa9d812571a9e5fb44">interpolateToFitScene()</a> and interpolateToZoomOnPixel(). </p>

</div>
</div>
<a class="anchor" id="a6d1e9c1493f1c3aa9d812571a9e5fb44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::interpolateToFitScene </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolates the <a class="el" href="classvortex_1_1_camera.html">Camera</a> on a one second KeyFrameInterpolator path so that the entire scene fits the screen at the end.</p>
<p>The scene is defined by its <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> and its <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a>. See <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a>.</p>
<p>The <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is not modified. See also interpolateToZoomOnPixel(). </p>

</div>
</div>
<a class="anchor" id="a01d952f360a936a9f249fc39f17dd2fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::IODistance </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the user's inter-ocular distance (in meters). Default value is 0.062m, which fits most people.
</pre><p>loadProjectionMatrixStereo() uses this value to define the <a class="el" href="classvortex_1_1_camera.html">Camera</a> offset and frustum. See <a class="el" href="classvortex_1_1_camera.html#a0a2326a2a78a93cbad71986b23d29e2a">setIODistance()</a>. </p>

</div>
</div>
<a class="anchor" id="a1189fadc88f07e516d8242d60510c24b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::lookAt </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>target</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a>, so that it looks at point <code>target</code> (defined in the world coordinate system).</p>
<p>The <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> is not modified. Simply <a class="el" href="classvortex_1_1_camera.html#a4034e9e88b920afce953fdbbd7bcb37c">setViewDirection()</a>.</p>
<p>See also <a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector()</a>, <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a>, <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a>, <a class="el" href="classvortex_1_1_camera.html#aedcae6d3c45c81a0d435c8b88465d685">fitSphere()</a> and <a class="el" href="classvortex_1_1_camera.html#a5bcb5a9e244705b8014a4e03fdd7662a">fitBoundingBox()</a>. </p>

</div>
</div>
<a class="anchor" id="a8efb3ed1304570980e74939e05a3ebc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvortex_1_1_camera.html">Camera</a> &amp; vortex::Camera::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_camera.html">Camera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equal operator.</p>
<p>All the parameters of <code>camera</code> are copied. The <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a> pointer is not modified, but its <a class="el" href="classvortex_1_1_frame.html#affb56783dfafab0d48f27ecccaccccc0">Frame::position()</a> and <a class="el" href="classvortex_1_1_frame.html#abb892d079ca208da22c85ae60824e025">Frame::orientation()</a> are set to those of <code>camera</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>The <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1fc5483c03649230f61281d5ea96534f">screenWidth()</a> and <a class="el" href="classvortex_1_1_camera.html#a92165f43ad31f84ae0824d6f0453d506">screenHeight()</a> are set to those of <code>camera</code>. If your <a class="el" href="classvortex_1_1_camera.html">Camera</a> is associated with a QGLViewer, you should update these value after the call to this method: <div class="fragment"><div class="line"> (camera()) = otherCamera;</div>
<div class="line">camera()-&gt;setScreenWidthAndHeight(width(), height());</div>
</div><!-- fragment --> The same applies to <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> and <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a>, if needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5608533b6c2b0398f2f7912075275f1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvortex_1_1_quaternion.html">Quaternion</a> vortex::Camera::orientation </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the Camera orientation, defined in the world coordinate system.
</pre><p>Actually returns <code><a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a>-&gt;<a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a></code>. Use <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a>, <a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector()</a> or <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a> to set the <a class="el" href="classvortex_1_1_camera.html">Camera</a> orientation. </p>

</div>
</div>
<a class="anchor" id="ad20ad016f143d6f9de36d8669f5c579f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::physicalDistanceToScreen </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the physical distance between the user's eyes and the screen (in meters).
</pre><p>Default value is 0.5m.</p>
<p>Used by loadModelViewMatrixStereo() and loadProjectionMatrixStereo() for stereo display. Value is set using <a class="el" href="classvortex_1_1_camera.html#ad12671e9e27ce10f7faea9ff5a2402c5">setPhysicalDistanceToScreen()</a>.</p>
<p><a class="el" href="classvortex_1_1_camera.html#ad20ad016f143d6f9de36d8669f5c579f">physicalDistanceToScreen()</a> and <a class="el" href="classvortex_1_1_camera.html#aaf462757a4fe400139a86da7355dbcd7">focusDistance()</a> represent the same distance. The first one is expressed in physical real world units, while the latter is expressed in OpenGL virtual world units. Use their ratio to convert distances between these worlds.</p>
<p>Use the following code to detect a reality center configuration (using its screen aspect ratio) and to automatically set physical distances accordingly: </p>
<div class="fragment"><div class="line">QDesktopWidget screen;</div>
<div class="line"><span class="keywordflow">if</span> (fabs((<span class="keywordtype">float</span>)screen.width() / (float)screen.height()) &gt; 2.0)</div>
<div class="line">{</div>
<div class="line">  camera()-&gt;setPhysicalDistanceToScreen(4.0);</div>
<div class="line">  camera()-&gt;setPhysicalScreenWidth(10.0);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acf6575485cfb4af6e21d1a4e0a1f5a87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::physicalScreenWidth </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the physical screen width, in meters. Default value is 0.4m (average monitor).
</pre><p>Used for stereo display only (see loadModelViewMatrixStereo() and loadProjectionMatrixStereo()). Set using <a class="el" href="classvortex_1_1_camera.html#ae2367c19e34ecb2d0647dd36f7bc560a">setPhysicalScreenWidth()</a>.</p>
<p>See <a class="el" href="classvortex_1_1_camera.html#ad20ad016f143d6f9de36d8669f5c579f">physicalDistanceToScreen()</a> for reality center automatic configuration. </p>

</div>
</div>
<a class="anchor" id="aa40590987298a6ce5b19f99562fd24f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::pixelGLRatio </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the ratio between pixel and OpenGL units at <code>position</code>.</p>
<p>A line of <code>n</code> * <a class="el" href="classvortex_1_1_camera.html#aa40590987298a6ce5b19f99562fd24f4">pixelGLRatio()</a> OpenGL units, located at <code>position</code> in the world coordinates system, will be projected with a length of <code>n</code> pixels on screen.</p>
<p>Use this method to scale objects so that they have a constant pixel size on screen. The following code will draw a 20 pixel line, starting at <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> and always directed along the screen vertical direction: </p>
<div class="fragment"><div class="line">glBegin(GL_LINES);</div>
<div class="line">glVertex3fv(<a class="code" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter</a>());</div>
<div class="line">glVertex3fv(<a class="code" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter</a>() + 20 * <a class="code" href="classvortex_1_1_camera.html#aa40590987298a6ce5b19f99562fd24f4">pixelGLRatio</a>(<a class="code" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter</a>()) * camera()-&gt;<a class="code" href="classvortex_1_1_camera.html#a32dd618393c7dee95370d0e2a9fe7f45">upVector</a>());</div>
<div class="line">glEnd();</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9cc35880e65eeca9151bf1336aa49edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::pointUnderPixel </td>
          <td>(</td>
          <td class="paramtype">const glm::ivec2 &amp;&#160;</td>
          <td class="paramname"><em>pixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the coordinates of the 3D point located at pixel (x,y) on screen.</p>
<p>Calls a <code>glReadPixel</code> to get the pixel depth and applies an <a class="el" href="classvortex_1_1_camera.html#a24a1d1b0f59fa99cd71ad959c97b6fa2">unprojectedCoordinatesOf()</a> to the result. <code>found</code> indicates whether a point was found or not (i.e. background pixel, result's depth is <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> in that case).</p>
<p><code>x</code> and <code>y</code> are expressed in pixel units with an origin in the upper left corner. Use <a class="el" href="classvortex_1_1_camera.html#a92165f43ad31f84ae0824d6f0453d506">screenHeight()</a> - y to convert to OpenGL standard.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method assumes that a GL context is available, and that its content was drawn using the <a class="el" href="classvortex_1_1_camera.html">Camera</a> (i.e. using its projection and modelview matrices). This method hence cannot be used for offscreen <a class="el" href="classvortex_1_1_camera.html">Camera</a> computations. Use <a class="el" href="classvortex_1_1_camera.html#ac5eb114fe3cd674667c421d302e39ec1">cameraCoordinatesOf()</a> and <a class="el" href="classvortex_1_1_camera.html#a246d49e52fc93293493be1b0d397022e">worldCoordinatesOf()</a> to perform similar operations in that case.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The precision of the z-Buffer highly depends on how the <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> values are fitted to your scene. Loose boundaries will result in imprecision along the viewing direction. </dd></dl>

</div>
</div>
<a class="anchor" id="a1289cba25a5f6fd5357242a108560d59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::position </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the Camera position (the eye), defined in the world coordinate system.
</pre><p>Use <a class="el" href="classvortex_1_1_camera.html#adc32a3c7e48488b2e7209788ae787b31">setPosition()</a> to set the <a class="el" href="classvortex_1_1_camera.html">Camera</a> position. Other convenient methods are <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a> or <a class="el" href="classvortex_1_1_camera.html#aedcae6d3c45c81a0d435c8b88465d685">fitSphere()</a>. Actually returns <code><a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a>-&gt;<a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a></code>.</p>
<p>This position corresponds to the projection center of a Camera::PERSPECTIVE <a class="el" href="classvortex_1_1_camera.html">Camera</a>. It is not located in the image plane, which is at a <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> distance ahead. </p>

</div>
</div>
<a class="anchor" id="a9a29d78038e810abb45cd72bd49be543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::projectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the screen projected coordinates of a point <code>src</code> defined in the <code>frame</code> coordinate system.</p>
<p>When <code>frame</code> in <code>NULL</code> (default), <code>src</code> is expressed in the world coordinate system.</p>
<p>The x and y coordinates of the returned Vec are expressed in pixel, (0,0) being the <em>upper</em> left corner of the window. The z coordinate ranges between 0.0 (near plane) and 1.0 (excluded, far plane). See the <code>gluProject</code> man page for details.</p>
<p><a class="el" href="classvortex_1_1_camera.html#a24a1d1b0f59fa99cd71ad959c97b6fa2">unprojectedCoordinatesOf()</a> performs the inverse transformation.</p>
<p>See the <a href="../examples/screenCoordSystem.html">screenCoordSystem example</a>.</p>
<p>This method only uses the intrinsic <a class="el" href="classvortex_1_1_camera.html">Camera</a> parameters (see getModelViewMatrix(), getProjectionMatrix() and <a class="el" href="classvortex_1_1_camera.html#a84a63df99f90547331028cf6b39adf9e">getViewport()</a>) and is completely independent of the OpenGL <code>GL_MODELVIEW</code>, <code>GL_PROJECTION</code> and viewport matrices. You can hence define a virtual <a class="el" href="classvortex_1_1_camera.html">Camera</a> and use this method to compute projections out of a classical rendering context.</p>
<dl class="section attention"><dt>Attention</dt><dd>However, if your <a class="el" href="classvortex_1_1_camera.html">Camera</a> is not attached to a QGLViewer (used for offscreen computations for instance), make sure the <a class="el" href="classvortex_1_1_camera.html">Camera</a> matrices are updated before calling this method. Call <a class="el" href="classvortex_1_1_camera.html#ab6d6cc36b2b1e70e7bda8c5ee53b0689">computeModelViewMatrix()</a> and <a class="el" href="classvortex_1_1_camera.html#a39a25f5ca6b165f7d7108fceb1ccded3">computeProjectionMatrix()</a> to do so.</dd></dl>
<p>If you call this method several times with no change in the matrices, consider precomputing the projection times modelview matrix to save computation time if required (<code>P</code> x <code>M</code> in the <code>gluProject</code> man page).</p>
<p>Here is the code corresponding to what this method does (kindly submitted by Robert W. Kuhn) : </p>
<div class="fragment"><div class="line">Vec project(Vec point)</div>
<div class="line">{</div>
<div class="line">       GLint    Viewport[4];</div>
<div class="line">       GLdouble Projection[16], Modelview[16];</div>
<div class="line">       GLdouble matrix[16];</div>
<div class="line"></div>
<div class="line">       <span class="comment">// Precomputation begin</span></div>
<div class="line">       glGetIntegerv(GL_VIEWPORT         , Viewport);</div>
<div class="line">       glGetDoublev (GL_MODELVIEW_MATRIX , Modelview);</div>
<div class="line">       glGetDoublev (GL_PROJECTION_MATRIX, Projection);</div>
<div class="line"></div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> m=0; m&lt;4; ++m)</div>
<div class="line">       {</div>
<div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> l=0; l&lt;4; ++l)</div>
<div class="line">               {</div>
<div class="line">                       <span class="keywordtype">double</span> sum = 0.0;</div>
<div class="line">                       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> k=0; k&lt;4; ++k)</div>
<div class="line">                               sum += Projection[l+4*k]*Modelview[k+4*m];</div>
<div class="line">                       matrix[l+4*m] = sum;</div>
<div class="line">               }</div>
<div class="line">       }</div>
<div class="line">       <span class="comment">// Precomputation end</span></div>
<div class="line"></div>
<div class="line">       GLdouble v[4], vs[4];</div>
<div class="line">       v[0]=point[0]; v[1]=point[1]; v[2]=point[2]; v[3]=1.0;</div>
<div class="line"></div>
<div class="line">       vs[0]=matrix[0 ]*v[0] + matrix[4 ]*v[1] + matrix[8 ]*v[2] + matrix[12 ]*v[3];</div>
<div class="line">       vs[1]=matrix[1 ]*v[0] + matrix[5 ]*v[1] + matrix[9 ]*v[2] + matrix[13 ]*v[3];</div>
<div class="line">       vs[2]=matrix[2 ]*v[0] + matrix[6 ]*v[1] + matrix[10]*v[2] + matrix[14 ]*v[3];</div>
<div class="line">       vs[3]=matrix[3 ]*v[0] + matrix[7 ]*v[1] + matrix[11]*v[2] + matrix[15 ]*v[3];</div>
<div class="line"></div>
<div class="line">       vs[0] /= vs[3];</div>
<div class="line">       vs[1] /= vs[3];</div>
<div class="line">       vs[2] /= vs[3];</div>
<div class="line"></div>
<div class="line">       vs[0] = vs[0] * 0.5 + 0.5;</div>
<div class="line">       vs[1] = vs[1] * 0.5 + 0.5;</div>
<div class="line">       vs[2] = vs[2] * 0.5 + 0.5;</div>
<div class="line"></div>
<div class="line">       vs[0] = vs[0] * Viewport[2] + Viewport[0];</div>
<div class="line">       vs[1] = vs[1] * Viewport[3] + Viewport[1];</div>
<div class="line"></div>
<div class="line">       <span class="keywordflow">return</span> Vec(vs[0], Viewport[3]-vs[1], vs[2]);</div>
<div class="line"> }</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>, cleanup !!! david : I have changed vp - y to -vp -y </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>, cleanup !!! david : I have changed vp - y to -vp -y </dd></dl>

</div>
</div>
<a class="anchor" id="a0d92abbc9be534611ddb522f2ef2e78a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::revolveAroundPoint </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The point the Camera revolves around with the QGLViewer::ROTATE mouse binding. Defined in world coordinate system.
</pre><p>Default value is the <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd><a class="el" href="classvortex_1_1_camera.html#a2814daeacfb2285fdda667fc78d712f3">setSceneCenter()</a> changes this value. </dd></dl>

</div>
</div>
<a class="anchor" id="af9b49368804f6d8d4d4fdda80ff3689e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::rightVector </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the normalized right vector of the Camera, defined in the world coordinate system.
</pre><p>This vector lies in the <a class="el" href="classvortex_1_1_camera.html">Camera</a> horizontal plane, directed along the X axis (orthogonal to <a class="el" href="classvortex_1_1_camera.html#a32dd618393c7dee95370d0e2a9fe7f45">upVector()</a> and to <a class="el" href="classvortex_1_1_camera.html#aa5614ba5cfab93d723c92ef0d2dcf79e">viewDirection()</a>). Set using <a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector()</a>, <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a> or <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a>.</p>
<p>Simply returns <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a>-&gt;inverseTransformOf(Vec(1.0, 0.0, 0.0)). </p>

</div>
</div>
<a class="anchor" id="a5e5347a5539dd6025aa90e13bef6c7df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::sceneCenter </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the position of the scene center, defined in the world coordinate system.
</pre><p>The scene observed by the <a class="el" href="classvortex_1_1_camera.html">Camera</a> should be roughly centered on this position, and included in a <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> sphere. This approximate description of the scene permits a <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> clipping planes definition, and allows convenient positioning methods such as <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a>.</p>
<p>Default value is (0,0,0) (world origin). Use <a class="el" href="classvortex_1_1_camera.html#a2814daeacfb2285fdda667fc78d712f3">setSceneCenter()</a> to change it. See also <a class="el" href="classvortex_1_1_camera.html#a630674741802fdb3f5c994d458adb67a">setSceneBoundingBox()</a>.</p>
<p>Note that QGLViewer::sceneCenter() (resp. QGLViewer::setSceneCenter()) simply call this method (resp. <a class="el" href="classvortex_1_1_camera.html#a2814daeacfb2285fdda667fc78d712f3">setSceneCenter()</a>) on its associated QGLViewer::camera(). </p>

</div>
</div>
<a class="anchor" id="ac4c76c53acc0d5004c3f7369ccb9b7b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::sceneRadius </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the radius of the scene observed by the Camera.
</pre><p>You need to provide such an approximation of the scene dimensions so that the <a class="el" href="classvortex_1_1_camera.html">Camera</a> can adapt its <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> values. See the <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> documentation.</p>
<p>See also <a class="el" href="classvortex_1_1_camera.html#a630674741802fdb3f5c994d458adb67a">setSceneBoundingBox()</a>.</p>
<p>Note that QGLViewer::sceneRadius() (resp. QGLViewer::setSceneRadius()) simply call this method (resp. <a class="el" href="classvortex_1_1_camera.html#a112797d898fffa9a90db74ff76bb39bd">setSceneRadius()</a>) on its associated QGLViewer::camera(). </p>

</div>
</div>
<a class="anchor" id="a92165f43ad31f84ae0824d6f0453d506"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vortex::Camera::screenHeight </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the height (in pixels) of the Camera screen.
</pre><p>Set using <a class="el" href="classvortex_1_1_camera.html#a6c128ba1ce34fc4680eb4a0e834f359b">setScreenWidthAndHeight()</a>. This value is automatically fitted to the QGLViewer's window dimensions when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is attached to a QGLViewer. See also QGLWidget::height() </p>

</div>
</div>
<a class="anchor" id="a1fc5483c03649230f61281d5ea96534f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vortex::Camera::screenWidth </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the width (in pixels) of the Camera screen.
</pre><p>Set using <a class="el" href="classvortex_1_1_camera.html#a6c128ba1ce34fc4680eb4a0e834f359b">setScreenWidthAndHeight()</a>. This value is automatically fitted to the QGLViewer's window dimensions when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is attached to a QGLViewer. See also QGLWidget::width() </p>

</div>
</div>
<a class="anchor" id="a346e108c921a16343f410bac8caaa5b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setAspectRatio </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Defines the Camera aspectRatio().
</pre><p>This value is actually inferred from the <a class="el" href="classvortex_1_1_camera.html#a1fc5483c03649230f61281d5ea96534f">screenWidth()</a> / <a class="el" href="classvortex_1_1_camera.html#a92165f43ad31f84ae0824d6f0453d506">screenHeight()</a> ratio. You should use <a class="el" href="classvortex_1_1_camera.html#a6c128ba1ce34fc4680eb4a0e834f359b">setScreenWidthAndHeight()</a> instead.</p>
<p>This method might however be convenient when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is not associated with a QGLViewer. It actually sets the <a class="el" href="classvortex_1_1_camera.html#a92165f43ad31f84ae0824d6f0453d506">screenHeight()</a> to 100 and the <a class="el" href="classvortex_1_1_camera.html#a1fc5483c03649230f61281d5ea96534f">screenWidth()</a> accordingly. See also <a class="el" href="classvortex_1_1_camera.html#a74492f523853959f56f3c6e17a17b198">setFOVToFitScene()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If you absolutely need an <a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio()</a> that does not correspond to your viewer's window dimensions, overload loadProjectionMatrix() or multiply the created GL_PROJECTION matrix by a scaled diagonal matrix in your QGLViewer::draw() method. </dd></dl>

</div>
</div>
<a class="anchor" id="a671d9d21ecca0cad24f03469dfa84bfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setFieldOfView </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fov</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Sets the vertical fieldOfView() of the Camera (in radians).
</pre><p>Note that <a class="el" href="classvortex_1_1_camera.html#aaf462757a4fe400139a86da7355dbcd7">focusDistance()</a> is set to <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> / tan(<a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a>/2) by this method. </p>

</div>
</div>
<a class="anchor" id="aa2ad234b9d36ca2088ddda022c82c1cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setFlySpeed </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>speed</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Sets the Camera flySpeed().
</pre><dl class="section attention"><dt>Attention</dt><dd>This value is modified by <a class="el" href="classvortex_1_1_camera.html#a112797d898fffa9a90db74ff76bb39bd">setSceneRadius()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a804e5653fc479d2d952638a3cf8b7c12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setFocusDistance </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distance</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html#aaf462757a4fe400139a86da7355dbcd7">focusDistance()</a>, in OpenGL scene units. </p>

</div>
</div>
<a class="anchor" id="a74492f523853959f56f3c6e17a17b198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setFOVToFitScene </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> so that the entire scene (defined by QGLViewer::sceneCenter() and QGLViewer::sceneRadius()) is visible from the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a>.</p>
<p>The <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> and <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> are not modified and you first have to orientate the <a class="el" href="classvortex_1_1_camera.html">Camera</a> in order to actually see the scene (see <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a>, <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a> or <a class="el" href="classvortex_1_1_camera.html#aedcae6d3c45c81a0d435c8b88465d685">fitSphere()</a>).</p>
<p>This method is especially useful for <em>shadow</em> <em>maps</em> computation. Use the <a class="el" href="classvortex_1_1_camera.html">Camera</a> positioning tools (<a class="el" href="classvortex_1_1_camera.html#adc32a3c7e48488b2e7209788ae787b31">setPosition()</a>, <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a>) to position a <a class="el" href="classvortex_1_1_camera.html">Camera</a> at the light position. Then use this method to define the <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> so that the shadow map resolution is optimally used: </p>
<div class="fragment"><div class="line"><span class="comment">// The light camera needs size hints in order to optimize its fieldOfView</span></div>
<div class="line">lightCamera-&gt;setSceneRadius(<a class="code" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius</a>());</div>
<div class="line">lightCamera-&gt;setSceneCenter(<a class="code" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Place the light camera.</span></div>
<div class="line">lightCamera-&gt;setPosition(lightFrame-&gt;position());</div>
<div class="line">lightCamera-&gt;lookAt(<a class="code" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter</a>());</div>
<div class="line">lightCamera-&gt;setFOVToFitScene();</div>
</div><!-- fragment --><p>See the (soon available) shadowMap contribution example for a practical implementation.</p>
<dl class="section attention"><dt>Attention</dt><dd>The <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> is clamped to M_PI/2.0. This happens when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is at a distance lower than sqrt(2.0) * <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> from the <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>. It optimizes the shadow map resolution, although it may miss some parts of the scene. </dd></dl>

</div>
</div>
<a class="anchor" id="a9293c396c9dd80c08382168e94653772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvortex_1_1_manipulated_camera_frame.html">ManipulatedCameraFrame</a> *const&#160;</td>
          <td class="paramname"><em>mcf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets the Camera frame().
</pre><p>If you want to move the <a class="el" href="classvortex_1_1_camera.html">Camera</a>, use <a class="el" href="classvortex_1_1_camera.html#adc32a3c7e48488b2e7209788ae787b31">setPosition()</a> and <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a> or one of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> positioning methods (<a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a>, <a class="el" href="classvortex_1_1_camera.html#aedcae6d3c45c81a0d435c8b88465d685">fitSphere()</a>, <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a>...) instead.</p>
<p>If you want to save the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a>, there's no need to call this method either. Use addKeyFrameToPath() and playPath() instead.</p>
<p>This method is actually mainly useful if you derive the <a class="el" href="classvortex_1_1_manipulated_camera_frame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific mouse bindings...">ManipulatedCameraFrame</a> class and want to use an instance of your new class to move the <a class="el" href="classvortex_1_1_camera.html">Camera</a>.</p>
<p>A <code>NULL</code> <code>mcf</code> pointer will silently be ignored. The calling method is responsible for deleting the previous <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a> pointer if needed in order to prevent memory leaks. </p>

</div>
</div>
<a class="anchor" id="a5c74b05c8f17a0f0d4c87607a1acad42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setFromModelViewMatrix </td>
          <td>(</td>
          <td class="paramtype">const GLdouble *const&#160;</td>
          <td class="paramname"><em>modelViewMatrix</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets the Camera's position() and orientation() from an OpenGL ModelView matrix.
</pre><p>This enables a <a class="el" href="classvortex_1_1_camera.html">Camera</a> initialisation from an other OpenGL application. <code>modelView</code> is a 16 GLdouble vector representing a valid OpenGL ModelView matrix, such as one can get using: </p>
<div class="fragment"><div class="line">GLdouble mvm[16];</div>
<div class="line">glGetDoublev(GL_MODELVIEW_MATRIX, mvm);</div>
<div class="line">myCamera-&gt;setFromModelViewMatrix(mvm);</div>
</div><!-- fragment --><p>After this method has been called, getModelViewMatrix() returns a matrix equivalent to <code>modelView</code>.</p>
<p>Only the <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> and <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> are modified.</p>
<dl class="section note"><dt>Note</dt><dd>If you defined your matrix as <code>GLdouble</code> <code>mvm</code>[4][4], pass <code>&amp;</code>(mvm[0][0]) as a parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="af324934e474347dd28d66fbaee52cd5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setFromProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>matrix</em>[12])</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a>, <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> and <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> from a projection matrix.</p>
<p><code>matrix</code> has to be given in the format used by vision algorithm. It has 3 lines and 4 columns. It transforms a point from the world homogeneous coordinate system (4 coordinates: <code>sx</code>, <code>sy</code>, <code>sz</code> and <code>s</code>) into a point in the screen homogeneous coordinate system (3 coordinates: <code>sx</code>, <code>sy</code>, and <code>s</code>, where <code>x</code> and <code>y</code> are the pixel coordinates on the screen).</p>
<p>Its three lines correspond to the homogeneous coordinates of the normals to the planes x=0, y=0 and z=0, defined in the <a class="el" href="classvortex_1_1_camera.html">Camera</a> coordinate system.</p>
<p>The elements of the matrix are ordered in line major order: you can call <code>setFromProjectionMatrix</code>(&amp;(matrix[0][0])) if you defined your matrix as a <code>float</code> <code>matrix</code>[3][4].</p>
<dl class="section attention"><dt>Attention</dt><dd>Passing the result of getProjectionMatrix() or getModelViewMatrix() to this method is not possible (purposefully incompatible matrix dimensions). <code>matrix</code> is more likely to be the product of these two matrices, without the last line.</dd></dl>
<p>Use <a class="el" href="classvortex_1_1_camera.html#a5c74b05c8f17a0f0d4c87607a1acad42">setFromModelViewMatrix()</a> to set <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> and <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> from a <code>GL_MODELVIEW</code> matrix. <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> can also be retrieved from a <em>perspective</em> <code>GL_PROJECTION</code> matrix using 2.0 * atan(1.0/projectionMatrix[5]).</p>
<p>This code was written by Sylvain Paris. </p>

</div>
</div>
<a class="anchor" id="a583bb3032b9f1c3c65793428a37bfad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setHorizontalFieldOfView </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hfov</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Sets the horizontalFieldOfView() of the Camera (in radians).
</pre><p><a class="el" href="classvortex_1_1_camera.html#ad744b096a4da01d11fdd4f4586468584">horizontalFieldOfView()</a> and <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> are linked by the <a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio()</a>. This method actually calls setFieldOfView(( 2.0 * atan (tan(hfov / 2.0) / <a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio()</a>) )) so that a call to <a class="el" href="classvortex_1_1_camera.html#ad744b096a4da01d11fdd4f4586468584">horizontalFieldOfView()</a> returns the expected value. </p>

</div>
</div>
<a class="anchor" id="a0a2326a2a78a93cbad71986b23d29e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setIODistance </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distance</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html#a01d952f360a936a9f249fc39f17dd2fd">IODistance()</a>. </p>

</div>
</div>
<a class="anchor" id="ade88484f8c977451ba8d2f94fa90535c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a>, defined in the world coordinate system. </p>

</div>
</div>
<a class="anchor" id="aad1ce99ba39088a8851e646cb0164377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setOrientation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html#a5608533b6c2b0398f2f7912075275f1e">orientation()</a> of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> using polar coordinates.</p>
<p><code>theta</code> rotates the <a class="el" href="classvortex_1_1_camera.html">Camera</a> around its Y axis, and <em>then</em> <code>phi</code> rotates it around its X axis. The polar coordinates are defined in the world coordinates system: <code>theta</code> = <code>phi</code> = 0 means that the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is directed towards the world Z axis. Both angles are expressed in radians.</p>
<p>See also <a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector()</a>. The <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is unchanged, you may want to call <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a> after this method to move the <a class="el" href="classvortex_1_1_camera.html">Camera</a>.</p>
<p>This method can be useful to create Quicktime VR panoramic sequences, see the QGLViewer::saveSnapshot() documentation for details. </p>

</div>
</div>
<a class="anchor" id="ad12671e9e27ce10f7faea9ff5a2402c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setPhysicalDistanceToScreen </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distance</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html#ad20ad016f143d6f9de36d8669f5c579f">physicalDistanceToScreen()</a>. </p>

</div>
</div>
<a class="anchor" id="ae2367c19e34ecb2d0647dd36f7bc560a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setPhysicalScreenWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the physical screen (monitor or projected wall) width (in meters). </p>

</div>
</div>
<a class="anchor" id="adc32a3c7e48488b2e7209788ae787b31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setPosition </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>pos</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> (the eye), defined in the world coordinate system. </p>

</div>
</div>
<a class="anchor" id="add8d6aaae2045b8160356abe5815b28b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setRevolveAroundPoint </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>rap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the <a class="el" href="classvortex_1_1_camera.html#a0d92abbc9be534611ddb522f2ef2e78a">revolveAroundPoint()</a> to <code>rap</code> (defined in the world coordinate system). </p>

</div>
</div>
<a class="anchor" id="a389bca49d39b2aa442de1fdab84c3681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vortex::Camera::setRevolveAroundPointFromPixel </td>
          <td>(</td>
          <td class="paramtype">const glm::ivec2 &amp;&#160;</td>
          <td class="paramname"><em>pixel</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The revolveAroundPoint() is set to the point located under \p pixel on screen.
</pre><p>Returns <code>true</code> if a <a class="el" href="classvortex_1_1_camera.html#a9cc35880e65eeca9151bf1336aa49edb">pointUnderPixel()</a> was found. If no point was found under <code>pixel</code>, the <a class="el" href="classvortex_1_1_camera.html#a0d92abbc9be534611ddb522f2ef2e78a">revolveAroundPoint()</a> is left unchanged.</p>
<p><code>pixel</code> is expressed in Qt format (origin in the upper left corner of the window). See <a class="el" href="classvortex_1_1_camera.html#a9cc35880e65eeca9151bf1336aa49edb">pointUnderPixel()</a>.</p>
<p>See also <a class="el" href="classvortex_1_1_camera.html#a149f2ed16798ba41e3b05057e87f19d3">setSceneCenterFromPixel()</a>. </p>

</div>
</div>
<a class="anchor" id="a630674741802fdb3f5c994d458adb67a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setSceneBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classvortex_1_1_camera.html#a112797d898fffa9a90db74ff76bb39bd">setSceneRadius()</a> and <a class="el" href="classvortex_1_1_camera.html#a2814daeacfb2285fdda667fc78d712f3">setSceneCenter()</a>, but the scene limits are defined by a (world axis aligned) bounding box. </p>

</div>
</div>
<a class="anchor" id="a2814daeacfb2285fdda667fc78d712f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setSceneCenter </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>center</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method also sets the <a class="el" href="classvortex_1_1_camera.html#a0d92abbc9be534611ddb522f2ef2e78a">revolveAroundPoint()</a> to <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a149f2ed16798ba41e3b05057e87f19d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vortex::Camera::setSceneCenterFromPixel </td>
          <td>(</td>
          <td class="paramtype">const glm::ivec2 &amp;&#160;</td>
          <td class="paramname"><em>pixel</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvortex_1_1_camera.html#a2814daeacfb2285fdda667fc78d712f3">setSceneCenter()</a> to the result of pointUnderPixel(<code>pixel</code>).</p>
<p>Returns <code>true</code> if a <a class="el" href="classvortex_1_1_camera.html#a9cc35880e65eeca9151bf1336aa49edb">pointUnderPixel()</a> was found and <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> was actually changed.</p>
<p>See also <a class="el" href="classvortex_1_1_camera.html#a389bca49d39b2aa442de1fdab84c3681">setRevolveAroundPointFromPixel()</a>. See the <a class="el" href="classvortex_1_1_camera.html#a9cc35880e65eeca9151bf1336aa49edb">pointUnderPixel()</a> documentation. </p>

</div>
</div>
<a class="anchor" id="a112797d898fffa9a90db74ff76bb39bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setSceneRadius </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets the sceneRadius() value. Negative values are ignored.
</pre><dl class="section attention"><dt>Attention</dt><dd>This methods also sets <a class="el" href="classvortex_1_1_camera.html#aaf462757a4fe400139a86da7355dbcd7">focusDistance()</a> to <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> / tan(<a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a>/2) and <a class="el" href="classvortex_1_1_camera.html#a3091775d697fb36f12543a5d14934111">flySpeed()</a> to 1% of <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c128ba1ce34fc4680eb4a0e834f359b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setScreenWidthAndHeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets Camera screenWidth() and screenHeight() (expressed in pixels).
</pre><p>You should not call this method when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is associated with a QGLViewer, since the latter automatically updates these values when it is resized (hence overwritting your values).</p>
<p>Non-positive dimension are silently replaced by a 1 pixel value to ensure frustrum coherence.</p>
<p>If your <a class="el" href="classvortex_1_1_camera.html">Camera</a> is used without a QGLViewer (offscreen rendering, shadow maps), use <a class="el" href="classvortex_1_1_camera.html#a346e108c921a16343f410bac8caaa5b1">setAspectRatio()</a> instead to define the projection matrix. </p>

</div>
</div>
<a class="anchor" id="a6d93047624bfbd509a6f565df19a2559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setType </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>type</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Defines the Camera type().
</pre><p>Changing the camera Type alters the viewport and the objects' size can be changed. This method garantees that the two frustum match in a plane normal to <a class="el" href="classvortex_1_1_camera.html#aa5614ba5cfab93d723c92ef0d2dcf79e">viewDirection()</a>, passing through the Revolve Around Point (RAP).</p>
<p>Prefix the type with <code><a class="el" href="classvortex_1_1_camera.html">Camera</a></code> if needed, as in: </p>
<div class="fragment"><div class="line">camera()-&gt;setType(Camera::ORTHOGRAPHIC);</div>
<div class="line"><span class="comment">// or even qglviewer::Camera::ORTHOGRAPHIC if you do not use namespace</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3a89a4bace6a3fc338efdfd7e53ad721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setUpVector </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noMove</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates the <a class="el" href="classvortex_1_1_camera.html">Camera</a> so that its <a class="el" href="classvortex_1_1_camera.html#a32dd618393c7dee95370d0e2a9fe7f45">upVector()</a> becomes <code>up</code> (defined in the world coordinate system).</p>
<p>The <a class="el" href="classvortex_1_1_camera.html">Camera</a> is rotated around an axis orthogonal to <code>up</code> and to the current <a class="el" href="classvortex_1_1_camera.html#a32dd618393c7dee95370d0e2a9fe7f45">upVector()</a> direction. Use this method in order to define the <a class="el" href="classvortex_1_1_camera.html">Camera</a> horizontal plane.</p>
<p>When <code>noMove</code> is set to <code>false</code>, the orientation modification is compensated by a translation, so that the <a class="el" href="classvortex_1_1_camera.html#a0d92abbc9be534611ddb522f2ef2e78a">revolveAroundPoint()</a> stays projected at the same position on screen. This is especially useful when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is an observer of the scene (default mouse binding).</p>
<p>When <code>noMove</code> is <code>true</code> (default), the <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> is left unchanged, which is an intuitive behavior when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is in a walkthrough fly mode (see the QGLViewer::MOVE_FORWARD and QGLViewer::MOVE_BACKWARD QGLViewer::MouseAction).</p>
<p>See also <a class="el" href="classvortex_1_1_camera.html#a4034e9e88b920afce953fdbbd7bcb37c">setViewDirection()</a>, <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a> and <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a>. </p>

</div>
</div>
<a class="anchor" id="a4034e9e88b920afce953fdbbd7bcb37c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setViewDirection </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>direction</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates the <a class="el" href="classvortex_1_1_camera.html">Camera</a> so that its <a class="el" href="classvortex_1_1_camera.html#aa5614ba5cfab93d723c92ef0d2dcf79e">viewDirection()</a> is <code>direction</code> (defined in the world coordinate system).</p>
<p>The <a class="el" href="classvortex_1_1_camera.html">Camera</a> <a class="el" href="classvortex_1_1_camera.html#a1289cba25a5f6fd5357242a108560d59">position()</a> is not modified. The <a class="el" href="classvortex_1_1_camera.html">Camera</a> is rotated so that the horizon (defined by its <a class="el" href="classvortex_1_1_camera.html#a32dd618393c7dee95370d0e2a9fe7f45">upVector()</a>) is preserved. See also <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a> and <a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector()</a>. </p>

</div>
</div>
<a class="anchor" id="a8988255d952260cf43d673bcec3fb976"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setZClippingCoefficient </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>coef</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> value. </p>

</div>
</div>
<a class="anchor" id="a700ee39b9e5178eec0c93f2220f44498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::setZNearCoefficient </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>coef</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classvortex_1_1_camera.html#a962f47b9c5987a99d9a7078158899d80">zNearCoefficient()</a> value. </p>

</div>
</div>
<a class="anchor" id="a088f6c5fe059fe18304704f0052822c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vortex::Camera::showEntireScene </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the <a class="el" href="classvortex_1_1_camera.html">Camera</a> so that the entire scene is visible.</p>
<p>Simply calls <a class="el" href="classvortex_1_1_camera.html#aedcae6d3c45c81a0d435c8b88465d685">fitSphere()</a> on a sphere defined by <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> and <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a>.</p>
<p>You will typically use this method in QGLViewer::init() after you defined a new <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a>. </p>

</div>
</div>
<a class="anchor" id="ab8fc643e877128e12ab607a78d5f9384"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type vortex::Camera::type </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the Camera::Type of the Camera.
</pre><p>Set by <a class="el" href="classvortex_1_1_camera.html#a6d93047624bfbd509a6f565df19a2559">setType()</a>. Mainly used by loadProjectionMatrix().</p>
<p>A Camera::PERSPECTIVE <a class="el" href="classvortex_1_1_camera.html">Camera</a> uses a classical projection mainly defined by its <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a>.</p>
<p>With a Camera::ORTHOGRAPHIC <a class="el" href="classvortex_1_1_camera.html#ab8fc643e877128e12ab607a78d5f9384">type()</a>, the <a class="el" href="classvortex_1_1_camera.html#a8522b4c00551b980a4bb7dc1ef0c3049">fieldOfView()</a> is meaningless and the width and height of the <a class="el" href="classvortex_1_1_camera.html">Camera</a> frustum are inferred from the distance to the <a class="el" href="classvortex_1_1_camera.html#a0d92abbc9be534611ddb522f2ef2e78a">revolveAroundPoint()</a> using <a class="el" href="classvortex_1_1_camera.html#a3bad4dd6c537b8bacea6a5123ff40a6d">getOrthoWidthHeight()</a>.</p>
<p>Both types use <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> (to define their clipping planes) and <a class="el" href="classvortex_1_1_camera.html#af76ad7a8235f8c049747b71062960859">aspectRatio()</a> (for frustum shape). </p>

</div>
</div>
<a class="anchor" id="a24a1d1b0f59fa99cd71ad959c97b6fa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::unprojectedCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvortex_1_1_frame.html">Frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the world unprojected coordinates of a point <code>src</code> defined in the screen coordinate system.</p>
<p>The <code>src.x</code> and <code>src.y</code> input values are expressed in pixels, (0,0) being the <em>upper</em> left corner of the window. <code>src.z</code> is a depth value ranging in [0..1[ (near and far plane respectively). See the <code>gluUnProject</code> man page for details.</p>
<p>The result is expressed in the <code>frame</code> coordinate system. When <code>frame</code> is <code>NULL</code> (default), the result is expressed in the world coordinates system. The possible <code>frame</code> <a class="el" href="classvortex_1_1_frame.html#ab821fcd094095085e55a779f1a9bfe8b">Frame::referenceFrame()</a> are taken into account.</p>
<p><a class="el" href="classvortex_1_1_camera.html#a9a29d78038e810abb45cd72bd49be543">projectedCoordinatesOf()</a> performs the inverse transformation.</p>
<p>This method only uses the intrinsic <a class="el" href="classvortex_1_1_camera.html">Camera</a> parameters (see getModelViewMatrix(), getProjectionMatrix() and <a class="el" href="classvortex_1_1_camera.html#a84a63df99f90547331028cf6b39adf9e">getViewport()</a>) and is completely independent of the OpenGL <code>GL_MODELVIEW</code>, <code>GL_PROJECTION</code> and viewport matrices. You can hence define a virtual <a class="el" href="classvortex_1_1_camera.html">Camera</a> and use this method to compute un-projections out of a classical rendering context.</p>
<dl class="section attention"><dt>Attention</dt><dd>However, if your <a class="el" href="classvortex_1_1_camera.html">Camera</a> is not attached to a QGLViewer (used for offscreen computations for instance), make sure the <a class="el" href="classvortex_1_1_camera.html">Camera</a> matrices are updated before calling this method (use <a class="el" href="classvortex_1_1_camera.html#ab6d6cc36b2b1e70e7bda8c5ee53b0689">computeModelViewMatrix()</a>, <a class="el" href="classvortex_1_1_camera.html#a39a25f5ca6b165f7d7108fceb1ccded3">computeProjectionMatrix()</a>). See also <a class="el" href="classvortex_1_1_camera.html#a6c128ba1ce34fc4680eb4a0e834f359b">setScreenWidthAndHeight()</a>.</dd></dl>
<p>This method is not computationally optimized. If you call it several times with no change in the matrices, you should buffer the entire inverse projection matrix (modelview, projection and then viewport) to speed-up the queries. See the <code>gluUnProject</code> man page for details. </p>

</div>
</div>
<a class="anchor" id="a32dd618393c7dee95370d0e2a9fe7f45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::upVector </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the normalized up vector of the Camera, defined in the world coordinate system.
</pre><p>Set using <a class="el" href="classvortex_1_1_camera.html#a3a89a4bace6a3fc338efdfd7e53ad721">setUpVector()</a> or <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a>. It is orthogonal to <a class="el" href="classvortex_1_1_camera.html#aa5614ba5cfab93d723c92ef0d2dcf79e">viewDirection()</a> and to <a class="el" href="classvortex_1_1_camera.html#af9b49368804f6d8d4d4fdda80ff3689e">rightVector()</a>.</p>
<p>It corresponds to the Y axis of the associated <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a> (actually returns <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a>-&gt;inverseTransformOf(Vec(0.0, 1.0, 0.0)) ). </p>

</div>
</div>
<a class="anchor" id="aa5614ba5cfab93d723c92ef0d2dcf79e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::viewDirection </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the normalized view direction of the Camera, defined in the world coordinate system.
</pre><p>Change this value using <a class="el" href="classvortex_1_1_camera.html#a4034e9e88b920afce953fdbbd7bcb37c">setViewDirection()</a>, <a class="el" href="classvortex_1_1_camera.html#a1189fadc88f07e516d8242d60510c24b">lookAt()</a> or <a class="el" href="classvortex_1_1_camera.html#ade88484f8c977451ba8d2f94fa90535c">setOrientation()</a>. It is orthogonal to <a class="el" href="classvortex_1_1_camera.html#a32dd618393c7dee95370d0e2a9fe7f45">upVector()</a> and to <a class="el" href="classvortex_1_1_camera.html#af9b49368804f6d8d4d4fdda80ff3689e">rightVector()</a>.</p>
<p>This corresponds to the negative Z axis of the <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a> ( <a class="el" href="classvortex_1_1_camera.html#a9521d0740c91a6247b81d97ef0f15778">frame()</a>-&gt;inverseTransformOf(Vec(0.0, 0.0, -1.0)) ). </p>

</div>
</div>
<a class="anchor" id="a246d49e52fc93293493be1b0d397022e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 vortex::Camera::worldCoordinatesOf </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>src</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the world coordinates of the point whose position \p src is defined in the Camera
</pre><p> coordinate system.</p>
<p><a class="el" href="classvortex_1_1_camera.html#ac5eb114fe3cd674667c421d302e39ec1">cameraCoordinatesOf()</a> performs the inverse transformation. </p>

</div>
</div>
<a class="anchor" id="ad539f59505f737c8c8eb95812d2e4dfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::zClippingCoefficient </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the coefficient used to position the near and far clipping planes.
</pre><p>The near (resp. far) clipping plane is positioned at a distance equal to <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> * <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> in front of (resp. behind) the <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>. This garantees an optimal use of the z-buffer range and minimizes aliasing. See the <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> documentations.</p>
<p>Default value is square root of 3.0 (so that a cube of size <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> is not clipped).</p>
<p>However, since the <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> is used for other purposes (see <a class="el" href="classvortex_1_1_camera.html#a088f6c5fe059fe18304704f0052822c0">showEntireScene()</a>, <a class="el" href="classvortex_1_1_camera.html#a3091775d697fb36f12543a5d14934111">flySpeed()</a>, ...) and you may want to change this value to define more precisely the location of the clipping planes. See also <a class="el" href="classvortex_1_1_camera.html#a962f47b9c5987a99d9a7078158899d80">zNearCoefficient()</a>.</p>
<p>For a total control on clipping planes' positions, an other option is to overload the <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> methods. See the <a href="../examples/standardCamera.html">standardCamera example</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>When QGLViewer::cameraPathAreEdited(), this value is set to 5.0 so that the <a class="el" href="classvortex_1_1_camera.html">Camera</a> paths are not clipped. The previous <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> value is restored back when you leave this mode. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5fb99c63836edcf1e09f4b9b4a6ae74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::zFar </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the far clipping plane distance used by the Camera projection matrix.
</pre><p>The far clipping plane is positioned at a distance equal to <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> * <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> behind the <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>: </p>
<div class="fragment"><div class="line"><a class="code" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar</a> = <a class="code" href="classvortex_1_1_camera.html#ae43369b846e40480b2923f7d2e94cc69">distanceToSceneCenter</a>() + <a class="code" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient</a>()*<a class="code" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius</a>();</div>
</div><!-- fragment --><p>See the <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> documentation for details. </p>

</div>
</div>
<a class="anchor" id="ac1409913192789a1f121ebd7fbe85f22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::zNear </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the near clipping plane distance used by the <a class="el" href="classvortex_1_1_camera.html">Camera</a> projection matrix.</p>
<p>The clipping planes' positions depend on the <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> and <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> rather than being fixed small-enough and large-enough values. A good scene dimension approximation will hence result in an optimal precision of the z-buffer.</p>
<p>The near clipping plane is positioned at a distance equal to <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> * <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> in front of the <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a>: </p>
<div class="fragment"><div class="line"><a class="code" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear</a> = <a class="code" href="classvortex_1_1_camera.html#ae43369b846e40480b2923f7d2e94cc69">distanceToSceneCenter</a>() - <a class="code" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient</a>()*<a class="code" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius</a>();</div>
</div><!-- fragment --><p>In order to prevent negative or too small <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> values (which would degrade the z precision), <a class="el" href="classvortex_1_1_camera.html#a962f47b9c5987a99d9a7078158899d80">zNearCoefficient()</a> is used when the <a class="el" href="classvortex_1_1_camera.html">Camera</a> is inside the <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a> sphere: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> zMin = <a class="code" href="classvortex_1_1_camera.html#a962f47b9c5987a99d9a7078158899d80">zNearCoefficient</a>() * <a class="code" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient</a>() * <a class="code" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius</a>();</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear</a> &lt; zMin)</div>
<div class="line">  <a class="code" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear</a> = zMin;</div>
<div class="line"><span class="comment">// With an ORTHOGRAPHIC type, the value is simply clamped to 0.0</span></div>
</div><!-- fragment --><p>See also the <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a>, <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> and <a class="el" href="classvortex_1_1_camera.html#a962f47b9c5987a99d9a7078158899d80">zNearCoefficient()</a> documentations.</p>
<p>If you need a completely different zNear computation, overload the <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> and <a class="el" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">zFar()</a> methods in a new class that publicly inherits from <a class="el" href="classvortex_1_1_camera.html">Camera</a> and use QGLViewer::setCamera(): </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>myCamera :: <span class="keyword">public</span> qglviewer::Camera</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">float</span> <a class="code" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">Camera::zNear</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0.001; };</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">float</span> <a class="code" href="classvortex_1_1_camera.html#ad5fb99c63836edcf1e09f4b9b4a6ae74">Camera::zFar</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 100.0; };</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the <a href="../examples/standardCamera.html">standardCamera example</a> for an application.</p>
<dl class="section attention"><dt>Attention</dt><dd>The value is always positive although the clipping plane is positioned at a negative z value in the <a class="el" href="classvortex_1_1_camera.html">Camera</a> coordinate system. This follows the <code>gluPerspective</code> standard. </dd></dl>

</div>
</div>
<a class="anchor" id="a962f47b9c5987a99d9a7078158899d80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float vortex::Camera::zNearCoefficient </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the coefficient which is used to set zNear() when the Camera is inside the sphere
</pre><p> defined by <a class="el" href="classvortex_1_1_camera.html#a5e5347a5539dd6025aa90e13bef6c7df">sceneCenter()</a> and <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> * <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a>.</p>
<p>In that case, the <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> value is set to <a class="el" href="classvortex_1_1_camera.html#a962f47b9c5987a99d9a7078158899d80">zNearCoefficient()</a> * <a class="el" href="classvortex_1_1_camera.html#ad539f59505f737c8c8eb95812d2e4dfd">zClippingCoefficient()</a> * <a class="el" href="classvortex_1_1_camera.html#ac4c76c53acc0d5004c3f7369ccb9b7b8">sceneRadius()</a>. See the <a class="el" href="classvortex_1_1_camera.html#ac1409913192789a1f121ebd7fbe85f22">zNear()</a> documentation for details.</p>
<p>Default value is 0.005, which is appropriate for most applications. In case you need a high dynamic ZBuffer precision, you can increase this value (~0.1). A lower value will prevent clipping of very close objects at the expense of a worst Z precision.</p>
<p>Only meaningful when <a class="el" href="classvortex_1_1_camera.html">Camera</a> type is Camera::PERSPECTIVE. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine/<a class="el" href="camera_8h_source.html">camera.h</a></li>
<li>src/engine/camera.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 29 2014 17:01:50 for BasicVortex by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
